<!doctype html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <title>Fuzzing_Armv7_Binaries_With_Docker // </title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.127.0">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Michael Poznecki" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.5b1fcc8902588589c4767187402a3c29f8b8d7a6fdef6d9f8f77045bb0d14fee.css" />
    

    
  


    
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Fuzzing_Armv7_Binaries_With_Docker">
  <meta name="twitter:description" content="Intro For the last six months or so, I have been attempting to figure out an efficient way to fuzz 32-bit ARM binaries while working in an x86 environment. I went into this knowing next to nothing, but have come out the other end with several key pieces of knowledge and a preferred workflow. If you are experienced in this area, you may be saying “Just use QEMU!”. You are correct, but there are two reasons this wasnt as easy as it should have been.">

    <meta property="og:url" content="http://localhost:1313/post/fuzzing_armv7_binaries_with_docker/">
  <meta property="og:title" content="Fuzzing_Armv7_Binaries_With_Docker">
  <meta property="og:description" content="Intro For the last six months or so, I have been attempting to figure out an efficient way to fuzz 32-bit ARM binaries while working in an x86 environment. I went into this knowing next to nothing, but have come out the other end with several key pieces of knowledge and a preferred workflow. If you are experienced in this area, you may be saying “Just use QEMU!”. You are correct, but there are two reasons this wasnt as easy as it should have been.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-07-14T12:04:19-05:00">
    <meta property="article:modified_time" content="2024-07-14T12:04:19-05:00">


  </head>
  <body>
    <header class="app-header">
      <a href="http://localhost:1313/"><img class="app-header-avatar" src="/avatar.jpg" alt="Michael Poznecki" /></a>
      <span class="app-header-title"></span>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/post/">Posts</a>
      </nav>
      <p>I blog mostly about hacking related stuff, sometimes stupid shit. Depends on the day.</p>
      <div class="app-header-social">
        
          <a href="https://github.com/rtandr01d" target="_blank" rel="noreferrer noopener me">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>Github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
          </a>
        
          <a href="https://defcon.social/@andr01d" target="_blank" rel="noreferrer noopener me">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-link">
  <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
  <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
</svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Fuzzing_Armv7_Binaries_With_Docker</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jul 14, 2024
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          4 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <h2 id="intro">Intro</h2>
<p>For the last six months or so, I have been attempting to figure out an efficient way to fuzz 32-bit ARM binaries while working in an x86 environment. I went into this knowing next to nothing, but have come out the other end with several key pieces of knowledge and a preferred workflow. If you are experienced in this area, you may be saying &ldquo;Just use QEMU!&rdquo;. You are correct, but there are two reasons this wasnt as easy as it should have been.</p>
<h2 id="afl">AFL++</h2>
<p>For the uninitiated, AFL++ (American Fuzzy Lop) is a tool used to fuzz command line programs. A typical install and usage is this: Compile and install AFL++ on your host, and use AFL&rsquo;s compiler stand-ins to instrument the program during compile. Then, using afl-fuzz perform fuzzing of the target. Simple. This is all fine for programs matching the host CPU architecture, but what if we wanted to fuzz programs created for other, sometimes exotic, architectures?</p>
<h3 id="qemu-mode">QEMU Mode</h3>
<p>QEMU is a system emulation suite. It can be used to run just a program via emulation or to emulate a whole sytem. More on emulating a system later. AFL++ can be built with a handy mode called QEMU mode. It does exactly what it sounds like. Running AFL with the &lsquo;-Q&rsquo; flag tells afl-fuzz to run the target via emulation. This does not just run the binary however, it will inject instrumentation at runtime. If you are trying to find vulenrabilities in a target program meant to run on embedded systems, this is likely your first and most widely known option. This comes with the caviate that your code coverage as compared to compiling the program with AFL will be significantly worse. If you have the source code to the program and cross-compile it using a standard gcc toolchain you will be limited in your fuzzing results.</p>
<p>To increase the code coverage when the source code is available, we can look to two possible methods: Cross-Compiling using AFL or full system emulation.</p>
<h3 id="cross-compiling">Cross-Compiling</h3>
<p>Admitedly, this is the worst option. However it was a good exercise for me in solving problems to achieve an interesting end goal. If you try to compile a program which was written for ARM devices with afl-gcc or any other AFL compiler, you will receive a ton of errors. I wont go over them here. Your best choice is to use &lsquo;afl-clang-fast&rsquo; as you can specify the flag &lsquo;&ndash;target=&rsquo; to compile for a target CPU architecture. This does not solve everything however, as a crucial piece of AFL is not built to compile ARM binaries. We can get around this by cross-compiling the object file &lsquo;afl-compiler-rt.o&rsquo; with a gcc toolchain:</p>
<p>![img][/images/afl-compiler-rt-compile.png]</p>
<p>This will allow us to compile and isntrument our ARM programs. Once we have our target binaries, we still need a way to run them on our x86 system. Passing the QEMU mode flag in afl-fuzz gives us a warning that the binary is already instrumented.</p>
<p>![img][/images/qemu-warning.png]</p>
<p>This leads us into the real solution to compiling, instrumenting and fuzzing ARM binaries: Docker with QEMU system emulation.</p>
<h3 id="qemu-afl">QEMU AFL++</h3>
<p>The official docker image for AFL++ has an ARM64 variant. This gave me the clue that we could potentially compile and install AFL on a 32-bit ARM docker image. A little googling howed there to be an armv7 (32-bit) Debian docker image in their official repo. After installing &lsquo;qemu-user-static&rsquo; and running the Docker image, it is as simple as git pulling the latest repo AFLplusplus and following the install instructions (<a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/INSTALL.md)">https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/INSTALL.md)</a>. Once we have all dependencies, running &lsquo;make all LLVM_CONFIG=llvm-config-14&rsquo; will make all the instrumentation and fuzzing binaries for AFL.</p>
<p>Since this install is on an armv7 Docker image, we can now compile and fuzz our target program &ldquo;natively&rdquo; by replacing all mentions of the gcc crosscompiling toolchain with &lsquo;afl-clang-fast&rsquo;. Note: to get your source code into the Docker image, I recomment passing the &lsquo;-v&rsquo; flag. Example: &lsquo;docker run -it -v /home/user/sourcecode:/src arm32v7/debian&rsquo;. This will mount your host&rsquo;s /home/user/sourcecode to /src in the Docker container.</p>
<p>Then, once everything has been compiled and instrumented, its as simple as running afl-fuzz on your target.</p>
<p>That is all for now.</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
